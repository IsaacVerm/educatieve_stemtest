# extract
parties <- lapply(test_data, function(x) x[["parties"]])
# unique parties in dataframe
parties <- unique(rbindlist(parties))
## categories
# extract
categories <- lapply(test_data, function(x) x[["categories"]])
# function to get into matrix format
categories_matrix <- function(categories_df) {
# table per domain
domain_table <- lapply(categories_df[["_stmts"]], function(x) table(x))
# maximum number of columns
max_col <- max(unlist(categories_df[["_stmts"]]))
# vector per domain
domain_vector <- lapply(categories_df[["_stmts"]],
function(x) rep(0, max_col))
mat <- mapply(FUN = function(vec,tab) {
vec[as.numeric(names(tab))] <- tab
return(vec) },
vec = domain_vector,
tab = domain_table)
# correct names matrix
colnames(mat) <- categories_df[["name"]]
return(mat)
}
# matrix format
categories <- lapply(categories, function(x) categories_matrix(x))
# dataframe format
freq_tests <- sapply(categories, nrow)
freq_tests
### setup
## paths
setup_path <- file.path(root_path,"functions","general purpose","setup.RData")
load_path <- file.path(root_path,"datasets","data","flemish_voting_test","test_data")
save_path <- file.path(root_path,"datasets","data","flemish_voting_test")
## setup environment
load(setup_path)
setup(c("jsonlite","stringr","data.table","dplyr"))
### get data
## data location
test_data_path <- list.files(load_path, full.names = TRUE)
## read data
test_data <- lapply(test_data_path, function(x) fromJSON(readLines(x)))
## rename data
names(test_data) <- gsub("test_data_|\\.txt","",list.files(load_path))
### extract information
## possible information
lapply(test_data, names)
## parties
# extract
parties <- lapply(test_data, function(x) x[["parties"]])
# unique parties in dataframe
parties <- unique(rbindlist(parties))
## categories
# extract
categories <- lapply(test_data, function(x) x[["categories"]])
# function to get into matrix format
categories_matrix <- function(categories_df) {
# table per domain
domain_table <- lapply(categories_df[["_stmts"]], function(x) table(x))
# maximum number of columns
max_col <- max(unlist(categories_df[["_stmts"]]))
# vector per domain
domain_vector <- lapply(categories_df[["_stmts"]],
function(x) rep(0, max_col))
mat <- mapply(FUN = function(vec,tab) {
vec[as.numeric(names(tab))] <- tab
return(vec) },
vec = domain_vector,
tab = domain_table)
# correct names matrix
colnames(mat) <- categories_df[["name"]]
return(mat)
}
# matrix format
categories <- lapply(categories, function(x) categories_matrix(x))
# dataframe format
freq_tests <- sapply(categories, nrow)
categories <- lapply(categories, function(x) as.data.frame(x))
categories <- rbindlist(categories, fill = TRUE)
categories$test <- mapply(rep, names(freq_tests), freq_tests)
View(categories)
names(freq_tests)
freq_tests
str(freq_tests)
mapply(rep, names(freq_tests), freq_tests)
categories$test <- unlist(mapply(rep, names(freq_tests), freq_tests))
View(categories)
# extract parties choices
parties_agree <- lapply(statements[["_agree"]], function(x) x[["id"]])
parties_no <- lapply(statements[["_noop"]], function(x) x[["id"]])
# parties choices in matrix
choices <- matrix(NA, nrow = nrow(statements), ncol = nrow(parties)) # empty matrix
choices <- mapply(FUN = function(mat,ind) {
mat[ind] <- 1
return(mat) },
mat = split(choices, rep(1:nrow(choices), each = ncol(choices))),
ind = parties_agree)
choices <- t(choices) # agree
choices[which(is.na(choices))] <- 0 # disagree
### setup
## paths
setup_path <- file.path(root_path,"functions","general purpose","setup.RData")
load_path <- file.path(root_path,"datasets","data","flemish_voting_test","test_data")
save_path <- file.path(root_path,"datasets","data","flemish_voting_test")
## setup environment
load(setup_path)
setup(c("jsonlite","stringr","data.table","dplyr"))
### get data
## data location
test_data_path <- list.files(load_path, full.names = TRUE)
## read data
test_data <- lapply(test_data_path, function(x) fromJSON(readLines(x)))
## rename data
names(test_data) <- gsub("test_data_|\\.txt","",list.files(load_path))
### extract information
## possible information
lapply(test_data, names)
## parties
# extract
parties <- lapply(test_data, function(x) x[["parties"]])
# unique parties in dataframe
parties <- unique(rbindlist(parties))
## categories
# extract
categories <- lapply(test_data, function(x) x[["categories"]])
# function to get into matrix format
categories_matrix <- function(categories_df) {
# table per domain
domain_table <- lapply(categories_df[["_stmts"]], function(x) table(x))
# maximum number of columns
max_col <- max(unlist(categories_df[["_stmts"]]))
# vector per domain
domain_vector <- lapply(categories_df[["_stmts"]],
function(x) rep(0, max_col))
mat <- mapply(FUN = function(vec,tab) {
vec[as.numeric(names(tab))] <- tab
return(vec) },
vec = domain_vector,
tab = domain_table)
# correct names matrix
colnames(mat) <- categories_df[["name"]]
return(mat)
}
# matrix format
categories <- lapply(categories, function(x) categories_matrix(x))
# dataframe format
freq_tests <- sapply(categories, nrow)
categories <- lapply(categories, function(x) as.data.frame(x))
categories <- rbindlist(categories, fill = TRUE)
categories$test <- unlist(mapply(rep, names(freq_tests), freq_tests))
## statements
# extract
statements <- lapply(test_data, function(x) x[["statements"]])
# add name test as variable
statements_freq <- sapply(statements, nrow)
name_test_statements <- unlist(mapply(rep, names(statements_freq), statements_freq))
# as dataframe
statements <- rbindlist(statements, fill = TRUE)
statements$test <- name_test_statements
# add statement id
statements$id <- unlist(lapply(statements_freq, function(x) 1:x))
# add parties
statements[ ,parties[["name"]]] <- NA
## statements agreements
# extract parties choices
parties_agree <- lapply(statements[["_agree"]], function(x) x[["id"]])
parties_no <- lapply(statements[["_noop"]], function(x) x[["id"]])
# parties choices in matrix
choices <- matrix(NA, nrow = nrow(statements), ncol = nrow(parties)) # empty matrix
choices <- mapply(FUN = function(mat,ind) {
mat[ind] <- 1
return(mat) },
mat = split(choices, rep(1:nrow(choices), each = ncol(choices))),
ind = parties_agree)
choices <- t(choices) # agree
choices[which(is.na(choices))] <- 0 # disagree
View(choices)
table(choices)
parties_no
no_rowind <- which(sapply(parties_no, function(x) class(x) == "integer"))
no_colind <- unlist(parties_no)
no_rowind
choices[no_rowind, no_colind]
### setup
## paths
setup_path <- file.path(root_path,"functions","general purpose","setup.RData")
load_path <- file.path(root_path,"datasets","data","flemish_voting_test","test_data")
save_path <- file.path(root_path,"datasets","data","flemish_voting_test")
## setup environment
load(setup_path)
setup(c("jsonlite","stringr","data.table","dplyr"))
### get data
## data location
test_data_path <- list.files(load_path, full.names = TRUE)
## read data
test_data <- lapply(test_data_path, function(x) fromJSON(readLines(x)))
## rename data
names(test_data) <- gsub("test_data_|\\.txt","",list.files(load_path))
### extract information
## possible information
lapply(test_data, names)
## parties
# extract
parties <- lapply(test_data, function(x) x[["parties"]])
# unique parties in dataframe
parties <- unique(rbindlist(parties))
## categories
# extract
categories <- lapply(test_data, function(x) x[["categories"]])
# function to get into matrix format
categories_matrix <- function(categories_df) {
# table per domain
domain_table <- lapply(categories_df[["_stmts"]], function(x) table(x))
# maximum number of columns
max_col <- max(unlist(categories_df[["_stmts"]]))
# vector per domain
domain_vector <- lapply(categories_df[["_stmts"]],
function(x) rep(0, max_col))
mat <- mapply(FUN = function(vec,tab) {
vec[as.numeric(names(tab))] <- tab
return(vec) },
vec = domain_vector,
tab = domain_table)
# correct names matrix
colnames(mat) <- categories_df[["name"]]
return(mat)
}
# matrix format
categories <- lapply(categories, function(x) categories_matrix(x))
# dataframe format
freq_tests <- sapply(categories, nrow)
categories <- lapply(categories, function(x) as.data.frame(x))
categories <- rbindlist(categories, fill = TRUE)
categories$test <- unlist(mapply(rep, names(freq_tests), freq_tests))
## statements
# extract
statements <- lapply(test_data, function(x) x[["statements"]])
# add name test as variable
statements_freq <- sapply(statements, nrow)
name_test_statements <- unlist(mapply(rep, names(statements_freq), statements_freq))
# as dataframe
statements <- rbindlist(statements, fill = TRUE)
statements$test <- name_test_statements
# add statement id
statements$id <- unlist(lapply(statements_freq, function(x) 1:x))
# add parties
statements[ ,parties[["name"]]] <- NA
## statements agreements
# extract parties choices
parties_agree <- lapply(statements[["_agree"]], function(x) x[["id"]])
parties_no <- lapply(statements[["_noop"]], function(x) x[["id"]])
# parties choices in matrix
choices <- matrix(NA, nrow = nrow(statements), ncol = nrow(parties)) # empty matrix
choices <- mapply(FUN = function(mat,ind) {
mat[ind] <- 1
return(mat) },
mat = split(choices, rep(1:nrow(choices), each = ncol(choices))),
ind = parties_agree)
choices <- t(choices) # agree
choices[which(is.na(choices))] <- 0 # disagree
no_rowind <- which(sapply(parties_no, function(x) class(x) == "integer"))
no_colind <- unlist(parties_no)
choices[40,10] <- NA
choices[41,8] <- NA # no opinion
# some parties don't exist for regional test
choices[76:110, 7:11] <- NA
# add parties choices
statements_agreement <- as.data.frame(statements)
parties_ind <- grep(pattern = "CD&V", x = names(statements)):ncol(statements)
statements_agreement[ ,parties_ind] <- choices
## statements weight
# extract parties weights
weights_agree <- lapply(statements[["_agree"]], function(x) x[["weight"]])
weights_disagree <- lapply(statements[["_disagree"]], function(x) x[["weight"]])
# add weight agreeing parties
weights <- t(as.matrix(statements_agreement[ ,parties_ind]))
weights[which(weights == 1)] <- unlist(weights_agree)
weights <- t(weights)
# add weight disagreeing parties
weights <- t(weights)
weights[which(weights == 0)] <- unlist(weights_disagree)
weights <- t(weights)
# add matrix weights to dataframe
statements_weight <- as.data.frame(statements_agreement)
statements_weight[ ,parties_ind] <- weights
View(statements_agreement)
View(statements_weight)
parties
View(parties)
### setup
## paths
setup_path <- file.path(root_path,"functions","general purpose","setup.RData")
load_path <- file.path(root_path,"datasets","data","flemish_voting_test","test_data")
save_path <- file.path(root_path,"datasets","data","flemish_voting_test")
## setup environment
load(setup_path)
setup(c("jsonlite","stringr","data.table","dplyr"))
### get data
## data location
test_data_path <- list.files(load_path, full.names = TRUE)
## read data
test_data <- lapply(test_data_path, function(x) fromJSON(readLines(x)))
## rename data
names(test_data) <- gsub("test_data_|\\.txt","",list.files(load_path))
### extract information
## possible information
lapply(test_data, names)
## parties
# extract
parties <- lapply(test_data, function(x) x[["parties"]])
# unique parties in dataframe
parties <- unique(rbindlist(parties))
## categories
# extract
categories <- lapply(test_data, function(x) x[["categories"]])
# function to get into matrix format
categories_matrix <- function(categories_df) {
# table per domain
domain_table <- lapply(categories_df[["_stmts"]], function(x) table(x))
# maximum number of columns
max_col <- max(unlist(categories_df[["_stmts"]]))
# vector per domain
domain_vector <- lapply(categories_df[["_stmts"]],
function(x) rep(0, max_col))
mat <- mapply(FUN = function(vec,tab) {
vec[as.numeric(names(tab))] <- tab
return(vec) },
vec = domain_vector,
tab = domain_table)
# correct names matrix
colnames(mat) <- categories_df[["name"]]
return(mat)
}
# matrix format
categories <- lapply(categories, function(x) categories_matrix(x))
# dataframe format
freq_tests <- sapply(categories, nrow)
categories <- lapply(categories, function(x) as.data.frame(x))
categories <- rbindlist(categories, fill = TRUE)
categories$test <- unlist(mapply(rep, names(freq_tests), freq_tests))
## statements
# extract
statements <- lapply(test_data, function(x) x[["statements"]])
# add name test as variable
statements_freq <- sapply(statements, nrow)
name_test_statements <- unlist(mapply(rep, names(statements_freq), statements_freq))
# as dataframe
statements <- rbindlist(statements, fill = TRUE)
statements$test <- name_test_statements
# add statement id
statements$id <- unlist(lapply(statements_freq, function(x) 1:x))
# add parties
statements[ ,parties[["name"]]] <- NA
## statements agreements
# extract parties choices
parties_agree <- lapply(statements[["_agree"]], function(x) x[["id"]])
parties_no <- lapply(statements[["_noop"]], function(x) x[["id"]])
# parties choices in matrix
choices <- matrix(NA, nrow = nrow(statements), ncol = nrow(parties)) # empty matrix
choices <- mapply(FUN = function(mat,ind) {
mat[ind] <- 1
return(mat) },
mat = split(choices, rep(1:nrow(choices), each = ncol(choices))),
ind = parties_agree)
choices <- t(choices) # agree
choices[which(is.na(choices))] <- 0 # disagree
no_rowind <- which(sapply(parties_no, function(x) class(x) == "integer"))
no_colind <- unlist(parties_no)
choices[40,10] <- NA
choices[41,8] <- NA # no opinion
# some parties don't exist for regional test
choices[76:110, 7:11] <- NA
# add parties choices
statements_agreement <- as.data.frame(statements)
parties_ind <- grep(pattern = "CD&V", x = names(statements)):ncol(statements)
statements_agreement[ ,parties_ind] <- choices
## statements weight
# extract parties weights
weights_agree <- lapply(statements[["_agree"]], function(x) x[["weight"]])
weights_disagree <- lapply(statements[["_disagree"]], function(x) x[["weight"]])
# add weight agreeing parties
weights <- t(as.matrix(statements_agreement[ ,parties_ind]))
weights[which(weights == 1)] <- unlist(weights_agree)
weights <- t(weights)
# add weight disagreeing parties
weights <- t(weights)
weights[which(weights == 0)] <- unlist(weights_disagree)
weights <- t(weights)
# add matrix weights to dataframe
statements_weight <- as.data.frame(statements_agreement)
statements_weight[ ,parties_ind] <- weights
### save objects
## parties
save(parties, file = file.path(save_path,"raw_parties.RData"))
## categories
save(categories, file = file.path(save_path,"raw_categories.RData"))
## statements
save(statements_agreement, file = file.path(save_path,"raw_statements_agreement.RData"))
save(statements_weight, file = file.path(save_path,"raw_statements_weight.RData"))
### setup
## paths
setup_path <- file.path(root_path,"functions","general purpose","setup.RData")
load_path <- file.path(root_path,"datasets","data","flemish_voting_test","test_data")
save_path <- file.path(root_path,"datasets","data","flemish_voting_test")
## setup environment
load(setup_path)
setup(c("jsonlite","stringr","data.table","dplyr"))
### get data
## data location
test_data_path <- list.files(load_path, full.names = TRUE)
## read data
test_data <- lapply(test_data_path, function(x) fromJSON(readLines(x)))
## rename data
names(test_data) <- gsub("test_data_|\\.txt","",list.files(load_path))
### extract information
## possible information
lapply(test_data, names)
## parties
# extract
parties <- lapply(test_data, function(x) x[["parties"]])
# unique parties in dataframe
parties <- unique(rbindlist(parties))
## categories
# extract
categories <- lapply(test_data, function(x) x[["categories"]])
# function to get into matrix format
categories_matrix <- function(categories_df) {
# table per domain
domain_table <- lapply(categories_df[["_stmts"]], function(x) table(x))
# maximum number of columns
max_col <- max(unlist(categories_df[["_stmts"]]))
# vector per domain
domain_vector <- lapply(categories_df[["_stmts"]],
function(x) rep(0, max_col))
mat <- mapply(FUN = function(vec,tab) {
vec[as.numeric(names(tab))] <- tab
return(vec) },
vec = domain_vector,
tab = domain_table)
# correct names matrix
colnames(mat) <- categories_df[["name"]]
return(mat)
}
# matrix format
categories <- lapply(categories, function(x) categories_matrix(x))
# dataframe format
freq_tests <- sapply(categories, nrow)
categories <- lapply(categories, function(x) as.data.frame(x))
categories <- rbindlist(categories, fill = TRUE)
categories$test <- unlist(mapply(rep, names(freq_tests), freq_tests))
## statements
# extract
statements <- lapply(test_data, function(x) x[["statements"]])
# add name test as variable
statements_freq <- sapply(statements, nrow)
name_test_statements <- unlist(mapply(rep, names(statements_freq), statements_freq))
# as dataframe
statements <- rbindlist(statements, fill = TRUE)
statements$test <- name_test_statements
# add statement id
statements$id <- unlist(lapply(statements_freq, function(x) 1:x))
# add parties
statements[ ,parties[["name"]]] <- NA
## statements agreements
# extract parties choices
parties_agree <- lapply(statements[["_agree"]], function(x) x[["id"]])
parties_no <- lapply(statements[["_noop"]], function(x) x[["id"]])
# parties choices in matrix
choices <- matrix(NA, nrow = nrow(statements), ncol = nrow(parties)) # empty matrix
choices <- mapply(FUN = function(mat,ind) {
mat[ind] <- 1
return(mat) },
mat = split(choices, rep(1:nrow(choices), each = ncol(choices))),
ind = parties_agree)
choices <- t(choices) # agree
choices[which(is.na(choices))] <- 0 # disagree
no_rowind <- which(sapply(parties_no, function(x) class(x) == "integer"))
no_colind <- unlist(parties_no)
choices[40,10] <- 2
choices[41,8] <- 2 # no opinion
# some parties don't exist for regional test
choices[76:110, 7:11] <- NA
# add parties choices
statements_agreement <- as.data.frame(statements)
parties_ind <- grep(pattern = "CD&V", x = names(statements)):ncol(statements)
statements_agreement[ ,parties_ind] <- choices
## statements weight
# extract parties weights
weights_agree <- lapply(statements[["_agree"]], function(x) x[["weight"]])
weights_disagree <- lapply(statements[["_disagree"]], function(x) x[["weight"]])
# add weight agreeing parties
weights <- t(as.matrix(statements_agreement[ ,parties_ind]))
weights[which(weights == 1)] <- unlist(weights_agree)
weights <- t(weights)
# add weight disagreeing parties
weights <- t(weights)
weights[which(weights == 0)] <- unlist(weights_disagree)
weights <- t(weights)
# add matrix weights to dataframe
statements_weight <- as.data.frame(statements_agreement)
statements_weight[ ,parties_ind] <- weights
### save objects
## parties
save(parties, file = file.path(save_path,"raw_parties.RData"))
## categories
save(categories, file = file.path(save_path,"raw_categories.RData"))
## statements
save(statements_agreement, file = file.path(save_path,"raw_statements_agreement.RData"))
save(statements_weight, file = file.path(save_path,"raw_statements_weight.RData"))
View(statements)
View(statements_agreement)
